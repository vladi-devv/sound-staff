# Coding Standards 2025

Этот раздел формализует правила именования и стандарты кодирования для всех частей проекта, чтобы обеспечить консистентность, читаемость и соответствие современным практикам.

## 1. Общие принципы

Эти принципы являются фундаментом для всего проекта и применяются ко всем языкам и частям кода. Они важнее, чем следование конкретному синтаксису.

### 1.1. Читаемость и Понятность

- **Язык:** Все имена (переменные, функции, классы, файлы, коммиты) должны быть на **английском языке**.
- **Осмысленность:** Имена должны быть описательными и самодокументируемыми. Избегайте однобуквенных переменных (кроме счетчиков в циклах `i, j, k`) и неочевидных сокращений.
  - **Плохо:** `$d`, `$arr`, `calculate()`.
  - **Хорошо:** `$orderData`, `$shipmentRates`, `calculateShipmentCost()`.
- **Именование булевых значений:** Переменные и функции, возвращающие булево значение, должны иметь префиксы, отвечающие на вопрос "да/нет": `is...`, `has...`, `can...`, `should...`.
  - **Пример:** `isReady`, `hasErrors`, `canCreateShipment`.
- **Консистентность:** Придерживайтесь выбранного стиля в рамках всего проекта. Если вы выбрали `camelCase` для переменных, используйте его везде.
- **Длина строки:** Старайтесь, чтобы длина строки не превышала 120 символов. Для кода это "мягкое" ограничение, для текста (комментарии, документация) — "жесткое".

### 1.2. Простота и Прямолинейность

- **KISS (Keep It Simple, Stupid):** Всегда предпочитайте простое и прямолинейное решение сложному. Если код трудно читать, его будет трудно поддерживать.
- **YAGNI (You Ain't Gonna Need It):** Не добавляйте функциональность, которая не требуется прямо сейчас. Избегайте преждевременной оптимизации и избыточного проектирования (over-engineering).
- **DRY (Don't Repeat Yourself):** Избегайте дублирования кода. Используйте функции, классы, миксины или другие абстракции для переиспользования общей логики.

- **Используйте Guard Clauses:** Вместо вложенных `if-else` конструкций, используйте "ранний возврат" (early return) для проверки ошибочных или крайних состояний в начале функции. Это уменьшает вложенность и делает основной, "счастливый" путь кода более линейным и читаемым.
  - **Плохо:**
    ```php
    public function processData($data) {
        if (is_array($data)) {
            if (!empty($data['key'])) {
                // ... основная логика ...
            }
        }
    }
    ```
  - **Хорошо:**
    ```php
    public function processData($data) {
        if (!is_array($data) || empty($data['key'])) {
            return;
        }
        // ... основная логика ...
    }
    ```

### 1.3. Надежность и Предсказуемость

- **Неизменяемость (Immutability):** По возможности, предпочитайте неизменяемые структуры данных. Вместо модификации существующего объекта или массива, создавайте новый с обновленными данными. Это делает состояние приложения более предсказуемым и уменьшает количество побочных эффектов.
- **Принцип единственной ответственности (Single Responsibility):** Каждая функция, класс или модуль должен иметь одну, и только одну, причину для изменения. Функция должна делать что-то одно и делать это хорошо.
- **Зависимость от абстракций (Dependency Inversion):** Код должен зависеть от абстракций (интерфейсов), а не от конкретных реализаций. Например, бизнес-логика должна работать с `DeliveryAdapterInterface`, а не напрямую с `NovaPoshtaAdapter`. Это позволяет легко заменять или добавлять новые службы доставки и делает код легко тестируемым (позволяя подменять реальные адаптеры на mock-объекты в тестах).
- **Идемпотентность операций (Idempotency):** Операции, изменяющие состояние (особенно при работе с внешними API, как создание ТТН), должны быть идемпотентными. Это означает, что повторное выполнение одной и той же операции (например, из-за сбоя сети) должно приводить к тому же результату, что и однократное, и не создавать дубликатов. Это достигается с помощью уникальных ключей запроса или проверок на существование ресурса перед созданием.
- **Явная обработка ошибок:** Не скрывайте ошибки. Используйте исключения для исключительных ситуаций. Ошибки должны быть обработаны явно, а не проигнорированы.

- **Безопасность по умолчанию (Secure by Design):** Безопасность включает как код приложения, так и его зависимости.
  - **Код:** При написании кода всегда думайте о безопасности. Экранируйте весь вывод (late escaping), используя подходящие функции WordPress (`esc_html`, `esc_attr`, `esc_url`, `wp_kses_post`) в момент вывода данных в HTML. Валидируйте все входящие данные, используйте nonces для AJAX-запросов и проверяйте права доступа.
  - **Зависимости:** Необходимо обеспечить безопасность зависимостей. В CI/CD пайплайн и локальные проверки должны быть встроены сканеры уязвимостей, такие как **`npm audit`** для JS и **`composer audit`** для PHP. Рекомендуется интеграция с **Dependabot** или **Snyk** на уровне репозитория для автоматического мониторинга.

- **Чистые функции (Pure Functions):** По возможности, функции и методы не должны иметь побочных эффектов (side effects). Для одного и того же набора входных данных они всегда должны возвращать один и тот же результат и не изменять состояние вне своей области видимости. Это делает код легко тестируемым и предсказуемым.

### 1.4. Комментарии и Документация

- **Язык комментариев:** Все комментарии и блоки документации (PHPDoc, JSDoc и т.д.) должны быть написаны на **английском языке**. Это обеспечивает консистентность с кодом и упрощает понимание для разработчиков, не говорящих на русском языке.
- **Комментируйте "почему", а не "что":** Код сам по себе объясняет, *что* он делает. Комментарии должны объяснять, *почему* было выбрано именно такое решение, особенно если оно неочевидно или является обходным путем для какой-то проблемы.
- **Стандарты документирования:** Для всех публичных API (классы, методы, функции) используйте стандартные форматы документирования: `PHPDoc` для PHP и `JSDoc` для JavaScript. Это обеспечивает автодополнение в IDE и возможность автоматической генерации документации.

### 1.5. Заголовки файлов (File Headers)

- **Обязательность:** Каждый PHP и JS файл должен начинаться с докблока (docblock), описывающего его назначение.
- **Содержание:** Заголовок должен содержать как минимум `@package` и краткое описание файла. Для WordPress-плагинов это стандартная практика, помогающая в навигации и поддержке.

### 1.6. Интернационализация (i18n)

- **Обязательность:** Все строки, предназначенные для вывода на экран пользователю (включая фронтенд и админ-панель), должны быть обернуты в соответствующие функции перевода WordPress.
- **Функции:** Используйте `__()` для возвращаемых строк, `_e()` для выводимых, `_x()` для строк с контекстом, `_n()` для строк с числительными.
- **Текстовый домен:** Все функции перевода должны использовать единый текстовый домен, определенный для плагина (например, `'woo-delivery'`).
- **Экранирование:** Не забывайте экранировать переведенные строки перед выводом.
  - **Пример:** `echo esc_html__( 'My Settings Page', 'woo-delivery' );`

### 1.7. Стандартизация окружения (Dev Containers)

- **Обязательность:** Для обеспечения полной идентичности среды разработки у всех членов команды, проект должен включать конфигурацию для **Dev Containers** (`devcontainer.json`).
- **Причина:** Это позволяет зафиксировать и автоматически настраивать окружение (версию PHP, Node.js, расширения IDE, системные зависимости) в Docker-контейнере, устраняя проблемы в стиле "у меня на машине все работает" и упрощая онбординг новых разработчиков.

### 1.8. Доступность (Accessibility, a11y)

- **Цель:** Весь разрабатываемый функционал должен соответствовать стандартам доступности, как минимум, уровня **WCAG 2.1 AA**. Это гарантирует, что люди с ограниченными возможностями смогут использовать продукт.
- **Семантический HTML:** Всегда используйте HTML-теги по их прямому назначению (`<nav>`, `<main>`, `<button>`, `<h1>` и т.д.). Это основа доступности, на которую полагаются вспомогательные технологии.
- **Навигация с клавиатуры:** Все интерактивные элементы (ссылки, кнопки, поля ввода) должны быть доступны и управляемы с помощью клавиатуры. Порядок фокуса должен быть логичным и предсказуемым.
- **ARIA-атрибуты:** Используйте ARIA-роли и атрибуты (`role`, `aria-label`, `aria-hidden` и т.д.) только тогда, когда семантики стандартного HTML недостаточно для описания роли или состояния компонента.
- **Контрастность цветов:** Текст и важные элементы интерфейса должны иметь достаточный коэффициент контрастности относительно фона, чтобы быть читаемыми для людей с нарушениями зрения.

## Специфичные стандарты

- [PHP](./php-style.md)
- [JavaScript/TypeScript/React](./js-style.md)
- [CSS/SCSS](./css-style.md)
- [Git](./git-style.md)
- [База данных](./database-style.md)
- [Прочее](./misc-style.md)