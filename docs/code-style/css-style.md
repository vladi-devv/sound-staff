## 4. CSS/SCSS (BEM)

Мы используем методологию BEM для именования классов, чтобы избежать конфликтов и сделать CSS предсказуемым и масштабируемым.

- **Файлы:** `kebab-case.scss`.
  - **Частичные файлы (partials):** Начинаются с подчеркивания `_` (например, `_variables.scss`, `_delivery-fields.scss`).

- **Папки/Директории:** Рекомендуется группировать файлы по назначению (например, `components/`, `layout/`, `utils/`).

- **Именование классов (BEM):**
  - **Блок:** Самостоятельный компонент. `kebab-case` с префиксом `wd-` (WooDelivery) для уникальности в экосистеме WordPress.
    - Пример: `.wd-delivery-fields`
  - **Элемент:** Часть блока, не имеющая смысла вне его. `__element-name`.
    - Пример: `.wd-delivery-fields__select`, `.wd-delivery-fields__loader`
  - **Модификатор:** Флаг, изменяющий внешний вид или состояние блока/элемента. `--modifier-name` (для пар ключ-значение) или `--is-modifier` (для булевых состояний).
    - Пример: `.wd-delivery-fields--loading`, `.wd-delivery-fields__select--disabled`

- **Переменные (CSS Custom Properties):** `kebab-case` с префиксом `--wd-` для избежания конфликтов.
  - Пример: `--wd-primary-color: #0073aa;`

- **Состояния (State Classes):** Глобальные классы состояний, управляемые через JS, должны иметь префикс `is-` или `has-`.
  - Пример: `.is-loading`, `.is-active`, `.has-error`. (Это дополняет BEM-модификаторы, которые применяются к конкретным блокам).

- **Миксины и функции (SCSS):** `kebab-case`.
  - Пример: `@mixin reset-list { ... }`, `@function get-color($key) { ... }`.

- **"Магические числа":** Избегайте использования необъяснимых числовых значений ("magic numbers") в стилях. Всегда используйте переменные (CSS Custom Properties) для отступов, размеров, z-индексов и т.д.
  - **Плохо:** `padding: 17px;`
  - **Хорошо:** `padding: var(--wd-spacing-medium);`
- **Единицы измерения:** Для обеспечения масштабируемости и доступности предпочитайте относительные единицы измерения (`rem`, `em`) для размеров шрифтов, отступов и большинства элементов макета. Абсолютные единицы (`px`) допустимы для элементов, размер которых не должен меняться (например, `border-width`).

- **Логические свойства (Logical Properties):** Для поддержки языков с письмом справа налево (RTL) предпочитайте логические свойства вместо физических.
  - **Плохо:** `margin-left`, `padding-right`, `border-left`.
  - **Хорошо:** `margin-inline-start`, `padding-inline-end`, `border-inline-start`.

- **Контейнерные запросы (Container Queries):** Для создания по-настоящему модульных компонентов, которые адаптируются к своему контексту, а не только к окну браузера, используйте **контейнерные запросы (`@container`)**. Это позволяет стилизовать компонент в зависимости от размеров его родительского элемента.

- **Современные цветовые пространства:** Для создания более предсказуемых и доступных цветовых палитр рекомендуется использовать современные цветовые функции, такие как **`oklch()`** или `lch()`. Они предоставляют доступ к более широкому цветовому охвату (P3) и работают в более интуитивном для человека формате.

- **Порядок свойств:** Для улучшения читаемости и консистентности, свойства внутри CSS-правила должны быть сгруппированы логически (например, позиционирование, блочная модель, типографика, визуальные эффекты, прочее). Рекомендуется использовать инструменты автоматического форматирования (например, Prettier с плагинами) для поддержания единого порядка.

## 4.1. Альтернатива: Utility-First CSS (Tailwind CSS)

Если в проекте используется Tailwind CSS, следующие правила заменяют или дополняют стандарт BEM.

- **Автоматическая сортировка классов:**
  - **Обязательность:** Для обеспечения единого порядка и читаемости, в проекте **обязательно** должен использоваться плагин **`prettier-plugin-tailwindcss`**. Он автоматически сортирует классы в стандартном, логичном порядке.

- **Стратегия применения утилит:**
  - **Приоритет на компоненты:** Длинные списки классов являются нормой. Однако, при частом повторении одного и того же набора утилит, следует отдавать предпочтение созданию **компонента фреймворка** (React, Vue, Blade), который инкапсулирует разметку и стили.
  - **Осторожное использование `@apply`:** Директиву `@apply` следует использовать с осторожностью. Она подходит для небольших, переиспользуемых наборов стилей, которые не являются полноценными компонентами (например, стили для кнопок `.btn`, `.btn-primary` или заголовков). Чрезмерное использование `@apply` может привести к созданию "BEM поверх Tailwind", что лишает фреймворк его преимуществ.

- **Конфигурация и Темизация (`tailwind.config.js`):**
  - **Централизация токенов:** Все значения, определяющие дизайн-систему (цвета, отступы, размеры шрифтов, точки останова), должны быть определены в объекте `theme` в файле `tailwind.config.js`.
  - **Избегайте "магических чисел":** Вместо использования произвольных значений в разметке (например, `top-[13px]`), следует расширять тему. Если нужен отступ `13px`, добавьте его в `theme.spacing`.

- **Произвольные значения (Arbitrary Values):**
  - **Исключительные случаи:** Использование произвольных значений (например, `w-[55px]`) допускается только в исключительных ситуациях, когда стиль действительно уникален и не является частью дизайн-системы (например, для исправления позиции элемента, зависящей от сторонней библиотеки).

- **Именование кастомных классов:**
  - **Простота и ясность:** При создании кастомных классов с помощью `@apply`, используйте простое и понятное именование в `kebab-case`.
    - **Пример:** `.main-title`, `.form-input`, `.card-wrapper`.

- **Модификаторы и состояния (`hover:`, `focus:`, `dark:`):**
  - **Логичная группировка:** Модификаторы состояний должны идти вместе с утилитой, которую они модифицируют. Плагин для Prettier позаботится об их порядке, но при написании кода старайтесь держать их сгруппированными для лучшей читаемости.
    - **Пример:** `bg-sky-500 hover:bg-sky-600 focus:ring-sky-500`