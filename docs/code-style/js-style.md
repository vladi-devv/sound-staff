## 3. JavaScript / TypeScript / React (Modern Best Practices)

Все общие правила для JavaScript, описанные ниже, применимы и к TypeScript.

- **Модульность и Импорты:**
  - **Фокус:** Каждый файл должен быть небольшим, сфокусированным модулем, который решает одну задачу.
  - **Абсолютные пути:** В проекте должны быть настроены абсолютные пути для импортов (например, через `tsconfig.json`). Это делает код более чистым и упрощает рефакторинг.
    - **Плохо:** `import { api } from '../../../../api';`
    - **Хорошо:** `import { api } from '@/api';`
- **Современный синтаксис (ES2020+):** Активно используйте возможности для повышения читаемости и надежности кода:
  - **Опциональная цепочка (`?.`):** Для безопасного доступа к вложенным свойствам. `const city = response?.data?.city;`
  - **Оператор нулевого слияния (`??`):** Для задания значений по умолчанию. `const timeout = options.timeout ?? 5000;`
  - **Деструктуризация:** Для работы с объектами и массивами. `const { name, phone } = recipient;`
- **Асинхронный код:** Предпочитайте синтаксис `async/await` для работы с промисами. Используйте `try...catch` для обработки ошибок.
- **Переменные и Константы:**
  - **Предпочтение `const`:** Всегда объявляйте переменные с помощью `const`. Используйте `let` только если переменная будет переприсвоена.
  - **Стиль:** `camelCase` (например, `selectedCityRef`).
  - **Глобальные константы:** `UPPER_CASE_SNAKE_CASE` (например, `const API_BASE_URL = '...'`).
- **Инструменты (Tooling):**
  - **Сборка:** Для сборки фронтенд-ассетов рекомендуется использовать современный сборщик **Vite**. Его система нативного ES-модулирования обеспечивает практически мгновенную горячую замену модулей (HMR) и значительно ускоряет разработку.
  - **Линтинг и форматирование:** Весь код должен проходить проверку линтером (ESLint) и автоматически форматироваться (Prettier) на основе единой конфигурации проекта.
  - **Конфигурация ESLint:** Должны быть включены и настроены плагины `eslint-plugin-react-hooks` (для отслеживания правильного использования хуков) и `eslint-plugin-jsx-a11y` (для обеспечения базовой доступности интерфейсов).

### 3.1. TypeScript

- **Строгая типизация:** Проект должен использовать строгий режим TypeScript (`"strict": true` в `tsconfig.json`). Это включает `strictNullChecks`, `noImplicitAny` и другие важные проверки.
- **Именование файлов:**
  - Файлы с React-компонентами: `PascalCase.tsx` (например, `DeliverySelector.tsx`).
  - Остальные файлы: `kebab-case.ts` (например, `api-client.ts`, `date-utils.ts`).
- **Типы vs Интерфейсы:**
  - **`type`:** Используйте для определения пропсов компонентов, состояния, и для создания сложных типов с использованием `union` и `intersection`. Это предпочтительный выбор для большинства сценариев в React.
    ```typescript
    type ShipmentProps = {
      orderId: number;
      onUpdate: (status: string) => void;
    };
    ```
  - **`interface`:** Используйте для определения "форм" объектов и классов, которые явно предназначены для расширения (`extends`) или реализации (`implements`), например, для API сервисов или библиотек.
    ```typescript
    interface DeliveryService {
      calculate(weight: number): number;
    }
    ```
- **Явное определение типов:** Всегда явно указывайте типы для аргументов функций, возвращаемых значений и сложных переменных. Полагайтесь на вывод типов (type inference) только для простых и очевидных случаев.
- **Utility Types:** Активно используйте встроенные утилиты для работы с типами: `Partial`, `Pick`, `Omit`, `Record` и др.
- **Enums:** Для определения набора констант предпочитайте `union types` из строковых литералов. Они более легковесны и лучше интегрируются с кодом, чем `enum`.

  ```typescript
  // Отлично
  type Status = 'pending' | 'shipped' | 'delivered';
  
  // Допустимо (если требуется объект со значениями)
  enum ShipmentStatus {
    Pending = 'pending',
    Shipped = 'shipped',
  }
  ```

### 3.2. React

- **Функциональные компоненты и хуки:** Всегда используйте функциональные компоненты с хуками. Классовые компоненты считаются устаревшими.
- **Именование:**
  - **Компоненты:** `PascalCase` (например, `function ShipmentTracker() { ... }`).
  - **Хуки:** `use` + `camelCase` (например, `function useWindowSize() { ... }`).
- **Пропсы (Props):**
  - **Типизация:** Всегда типизируйте пропсы компонента с помощью TypeScript.
  - **Деструктуризация:** Деструктурируйте пропсы в начале компонента для ясности.

    ```tsx
    type UserProfileProps = { userId: number };
    
    function UserProfile({ userId }: UserProfileProps) {
      // ...
    }
    ```

- **Состояние (State):**
  - **Клиентское состояние (Client State):**
    - **Локальное:** `useState` для простого состояния, `useReducer` для сложной логики внутри компонента.
    - **Глобальное:** Для состояния, которое необходимо разделять между несвязанными компонентами, рекомендуется использовать легковесные библиотеки, такие как **Zustand** или **Jotai**. Они предоставляют простой API и являются современной альтернативой Redux.
  - **Серверное состояние (Server State):** Для управления данными, получаемыми с сервера (загрузка, кэширование, обновление, синхронизация), **обязательно** использовать специализированные библиотеки, такие как **React Query (TanStack Query)** или **SWR**. Не следует хранить серверные данные в `useState` или `useEffect` вручную.
    - **Пример (React Query):**
      ```tsx
      function UserProfile({ userId }: UserProfileProps) {
        const { data, isLoading, error } = useQuery({
          queryKey: ['user', userId],
          queryFn: () => fetchUser(userId),
        });
        // ...
      }
      ```
- **Кастомные хуки (Custom Hooks):**
  - **Переиспользование логики:** Любая нетривиальная логика, особенно включающая в себя несколько хуков (`useState`, `useEffect`, `useContext`), должна быть вынесена в кастомный хук. Это основной механизм переиспользования логики в React.
    - **Пример:** `useDebounce`, `useFormInput`, `useAuth`.
- **Производительность (Performance):**
  - **Мемоизация:** Используйте `React.memo` для предотвращения повторного рендера компонента, если его пропсы не изменились. Применяйте `useMemo` для кэширования результатов сложных вычислений и `useCallback` для мемоизации функций, передаваемых в дочерние компоненты.
  - **Предостережение:** Не занимайтесь преждевременной оптимизацией. Используйте эти инструменты только после профилирования (например, с помощью React DevTools Profiler) и обнаружения реальных проблем с производительностью.
- **Изолированная разработка компонентов (Storybook):**
  - **Рекомендация:** Для разработки, тестирования и документирования UI-компонентов в изоляции от основного приложения следует использовать **Storybook**.
  - **Цель:** Это ускоряет разработку, упрощает визуальное тестирование и создает живую, интерактивную документацию для UI-кита проекта.
- **Обработка ошибок:**
  - **Error Boundaries:** Оборачивайте независимые части UI (например, виджеты, страницы) в **Error Boundary**. Это компоненты, которые отлавливают ошибки рендеринга в своем дочернем дереве и отображают запасной UI вместо падения всего приложения.
- **Структура и стилизация:**
  - **Колокация:** Связанные файлы должны находиться вместе. Компонент, его стили, хуки и тесты должны лежать в одной папке.
    ```
    /components
      /UserProfile
        - UserProfile.tsx
        - UserProfile.module.css  // или UserProfile.styled.ts
        - useUserProfile.ts
        - UserProfile.test.tsx
    ```
  - **Стилизация:** Проект должен придерживаться одного из подходов к стилизации:
    - **CSS Modules:** (`.module.css`) — для локальной области видимости классов (рекомендуется по умолчанию).
    - **CSS-in-JS:** (например, `styled-components`, `emotion`) — для динамических стилей, тесно связанных с состоянием компонента.
    - **Utility-first CSS:** (например, `Tailwind CSS`) — для быстрой разработки с использованием готовых классов.
- **Ключи в списках (`key`):** При рендеринге списков всегда используйте стабильный и уникальный `key` для каждого элемента (например, `item.id`). Не используйте индекс массива в качестве ключа, если список может изменяться.
- **Тестирование:** Для привязки к DOM-элементам в тестах используйте `data-testid` или `data-cy` атрибуты.
  - **Хорошо:** `<button data-testid="create-shipment-button">Создать</button>
