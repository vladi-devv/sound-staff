## 2. PHP (PSR-12 + WordPress Best Practices)

Мы придерживаемся стандарта **PSR-12** как основы для форматирования кода. Однако, для обеспечения полной совместимости и идиоматичности в экосистеме WordPress, мы также следуем **WordPress Coding Standards** в тех аспектах, где они имеют свои особенности.

- **Приоритет:** В случае прямого конфликта, правила WordPress Coding Standards имеют приоритет (например, в именовании функций или использовании `elseif` вместо `else if`).
- **Ключевые отличия от чистого PSR-12, которые мы принимаем:**
  - Использование `snake_case` для глобальных функций и хуков.
  - Пробелы внутри скобок управляющих конструкций: `if ( $condition )`.
  - Использование `elseif` вместо `else if`.
  - Многострочные вызовы функций и массивы форматируются в стиле WordPress.

- **Файлы:**
  - **Классы, Интерфейсы, Трейты, Enums:** `PascalCase.php` (например, `NovaPoshtaAdapter.php`).
  - **Файлы шаблонов и конфигураций:** `kebab-case.php` (например, `delivery-fields.php`, `delivery.php.example`).
  - **Главный файл плагина:** `kebab-case.php` (например, `wc-delivery.php`).

- **Папки/Директории:**
  - **Содержащие классы (PSR-4):** `PascalCase` (например, `src/Adapters/`, `src/Domain/`).
  - **Остальные (ресурсы, шаблоны):** `kebab-case` (например, `assets/`, `templates/`, `config/`).

- **Классы:** `PascalCase` (например, `Shipment`, `Settings`).
  - **Абстрактные классы:** Могут иметь префикс `Abstract` (например, `AbstractDeliveryAdapter`).

- **Использование `final`:** Классы, которые не предназначены для наследования (например, DTO, классы-утилиты), должны быть объявлены как `final`. Это предотвращает непреднамеренное расширение и делает архитектуру более строгой и предсказуемой.

- **Строгая типизация:** Все PHP-файлы должны начинаться с `declare(strict_types=1);`. Все свойства, аргументы методов и возвращаемые значения должны иметь максимально строгие типы.
  - **Предпочтение Enums:** Используйте Enums для определения закрытого набора возможных состояний или значений (например, `ShipmentStatus::DELIVERED`). Используйте константы для простых, единичных конфигурационных значений (например, `const DEFAULT_TTL = 3600;`).

- **Неизменяемость через `readonly`:** Для DTO и Value Objects используйте `readonly` свойства (PHP 8.1+) или `readonly` классы (PHP 8.2+). Это является наивысшей формой обеспечения неизменяемости на уровне языка.
- **Интерфейсы:** `PascalCase` с суффиксом `Interface` (например, `DeliveryAdapterInterface`).

- **Трейты:** `PascalCase` с суффиксом `Trait` (например, `HasLoggerTrait`).

- **Enums:** `PascalCase` (например, `ShipmentStatus`).

- **Методы классов:** `camelCase` (например, `createShipment`, `getTrackingUrl`).

- **Функции (глобальные, в `helpers.php`):** `snake_case` с префиксом плагина для избежания конфликтов (например, `woo_delivery_get_service_label()`).

- **Переменные:**
  - **Свойства классов и локальные переменные:** `camelCase` (например, `$apiClient`, `$orderId`).
  - **Переменные, передаваемые в шаблоны:** `snake_case` для соответствия стилю WordPress (например, `<?php echo $tracking_url; ?>`).

- **Константы:**
  - **Ключи в конфигурационных массивах:** `snake_case` (например, в файле `config/delivery.php`: `'api_key' => '...'`).

- **Документирование типов (PHPDoc):**
  - **Массивы объектов:** Для типизации массивов, содержащих объекты одного класса, всегда используйте синтаксис `ClassName[]`.
    - **Пример:** `/** @param ShipmentDTO[] $shipments */`
  - **Классовые константы:** `UPPER_CASE_SNAKE_CASE` (например, `const DEFAULT_TTL = 3600;`).

- **Пространства имен (Namespaces):** `PascalCase` (например, `WooDelivery\Core`, `WooDelivery\Adapters\NovaPoshta`).

- **Хуки (Actions/Filters):** `plugin_slug/group/name` для уникальности.
  - Пример: `woo_delivery/shipment/before_create`, `woo_delivery/api/request_args`.

- **Методы-обработчики хуков:** Методы класса, используемые в качестве колбэков для хуков WordPress, рекомендуется называть с префиксом `on_` или `handle_`.
  - **Пример:** `public function on_order_status_changed(...) { ... }`

- **Опции в `wp_options`:** `plugin_slug_group_name`.
  - Пример: `wd_settings`, `wd_sender_profiles`.

- **Мета-поля:** Начинаются с `_` для скрытия в стандартном UI WordPress. `_plugin_slug_name`.
  - Пример: `_wd_shipment_ttn`, `_wd_parcels`.

### 2.1. Статический анализ (Static Analysis)

- **Обязательность:** Весь код должен проходить проверку статическим анализатором (PHPStan) с уровнем не ниже **6**, с целью постепенного повышения до 7-8.
- **Цель:** Обнаружение потенциальных ошибок, несоответствий типов и "мертвого" кода на раннем этапе, до выполнения. Более высокие уровни обеспечивают значительно более строгий контроль.

### 2.2. Тесты (Tests)

- **Именование файлов:** Имя тестового файла должно соответствовать имени тестируемого класса с суффиксом `Test`. (например, `ShipmentTest.php`).
- **Именование методов:** Методы должны быть описательными, используя `snake_case` и отражать проверяемый сценарий.
  - Пример: `public function test_it_correctly_calculates_total_weight()`.

### 2.3. Атрибуты (Attributes)

- **Форматирование:** Каждый атрибут должен располагаться на отдельной строке перед объявлением класса, метода или свойства. Это улучшает читаемость.
  - Пример:
    ```php
    #[Route('/api/orders/{id}', methods: ['GET'])]
    #[CurrentUserCan('manage_woocommerce')]
    public function getOrder(int $id): WP_REST_Response
    ```

### 2.4. Продвижение Атрибутов

- **Предпочтение атрибутов:** Следует поощрять использование **атрибутов PHP 8+** вместо PHPDoc-аннотаций для таких задач, как валидация, сериализация и конфигурация DI.
- **Причина:** Атрибуты являются нативной частью языка, в отличие от комментариев. Они типизированы и поддерживаются IDE и статическими анализаторами на более высоком уровне, что делает код более надежным.

### 2.5. WooCommerce Best Practices

При разработке под WooCommerce, мы придерживаемся всех стандартов WordPress, описанных выше, но с добавлением специфичных для WooCommerce практик для обеспечения максимальной совместимости и надежности.

- **Основа:** Стандарты кодирования WordPress являются базовыми. Все правила PHP, именования и безопасности применимы в полной мере.
- **Автоматическая проверка кода:** В дополнение к основным правилам WordPress, код должен проходить проверку с использованием набора правил **`woocommerce/woocommerce-sniffs`**. Это обеспечивает соответствие специфичным для WooCommerce соглашениям.
- **Архитектура:**
  - **Использование хуков:** Логика должна расширять WooCommerce через хуки (actions и filters), а не через прямое изменение шаблонов или ядра.
  - **Модульность:** Код следует организовывать в виде самодостаточных классов для улучшения структуры и упрощения поддержки.
- **Интернационализация:** Все строки должны быть переводимы с использованием единого текстового домена плагина (например, `'woo-delivery'`).
